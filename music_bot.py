import os
import tempfile
import asyncio
import logging
from pathlib import Path
from typing import Optional
import time
import urllib.parse
import re

from aiogram import Bot, Dispatcher, types, F
from aiogram.filters import Command
from aiogram.types import Message, InlineKeyboardMarkup, InlineKeyboardButton, CallbackQuery
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from aiogram.fsm.storage.memory import MemoryStorage

import yt_dlp
import requests
from bs4 import BeautifulSoup
from dotenv import load_dotenv

load_dotenv()

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
BOT_TOKEN = os.getenv("BOT_TOKEN")
MAX_FILE_SIZE = 50 * 1024 * 1024  # 50MB Telegram limit
MAX_DURATION = 600  # 10 minutes max duration
TEMP_DIR = tempfile.gettempdir()

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–æ—Ç–∞
bot = Bot(token=BOT_TOKEN)
storage = MemoryStorage()
dp = Dispatcher(storage=storage)

# –¢–µ–∫—Å—Ç—ã —Å–æ–æ–±—â–µ–Ω–∏–π
TEXTS = {
    "welcome": """üéµ **–ú—É–∑—ã–∫–∞–ª—å–Ω—ã–π –±–æ—Ç —Å –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–º–∏ –∏—Å—Ç–æ—á–Ω–∏–∫–∞–º–∏**

**–ß—Ç–æ —è —É–º–µ—é:**
‚Ä¢ üîç –ò—â—É –º—É–∑—ã–∫—É –≤ —Ä–∞–∑–Ω—ã—Ö –∏—Å—Ç–æ—á–Ω–∏–∫–∞—Ö –∏–Ω—Ç–µ—Ä–Ω–µ—Ç–∞
‚Ä¢ üì§ –û—Ç–ø—Ä–∞–≤–ª—è—é —Ç—Ä–µ–∫–∏ –≤ –≤—ã—Å–æ–∫–æ–º –∫–∞—á–µ—Å—Ç–≤–µ MP3
‚Ä¢ üåê –ò—Å–ø–æ–ª—å–∑—É—é –Ω–µ—Å–∫–æ–ª—å–∫–æ –ø–ª–æ—â–∞–¥–æ–∫ –¥–ª—è –ø–æ–∏—Å–∫–∞
‚Ä¢ ‚ö° –ù–∞–π–¥—É –¥–∞–∂–µ —Ä–µ–¥–∫–∏–µ –∫–æ–º–ø–æ–∑–∏—Ü–∏–∏

**–ò—Å—Ç–æ—á–Ω–∏–∫–∏ –ø–æ–∏—Å–∫–∞:**
‚Ä¢ YouTube (—á–µ—Ä–µ–∑ yt-dlp)
‚Ä¢ Zaycev.net (—Ä—É—Å—Å–∫–æ—è–∑—ã—á–Ω–∞—è –º—É–∑—ã–∫–∞)
‚Ä¢ –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–µ –∏—Å—Ç–æ—á–Ω–∏–∫–∏

**–ö–∞–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è:**
–ü—Ä–æ—Å—Ç–æ –Ω–∞–ø–∏—à–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ —Ç—Ä–µ–∫–∞ –∏–ª–∏ –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—è

**–ü—Ä–∏–º–µ—Ä—ã:**
‚Ä¢ Imagine Dragons Radioactive
‚Ä¢ The Beatles Hey Jude
‚Ä¢ –ú–æ–Ω–µ—Ç–æ—á–∫–∞ –ö–∞–∂–¥—ã–π —Ä–∞–∑
‚Ä¢ Miyagi Kosandra

–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:""",

    "help": """üÜò **–°–ø—Ä–∞–≤–∫–∞ –ø–æ –º–Ω–æ–≥–æ–∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤–æ–º—É –±–æ—Ç—É**

**–û—Å–Ω–æ–≤–Ω—ã–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏:**
üîç **–ü–æ–∏—Å–∫ –º—É–∑—ã–∫–∏** - –Ω–∞–ø–∏—à–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ —Ç—Ä–µ–∫–∞ –∏–ª–∏ –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—è

**–ò—Å—Ç–æ—á–Ω–∏–∫–∏ –ø–æ–∏—Å–∫–∞ (–ø–æ –ø–æ—Ä—è–¥–∫—É):**
1. üé• **YouTube** - —Å–∞–º–∞—è –±–æ–ª—å—à–∞—è –±–∞–∑–∞ —Ç—Ä–µ–∫–æ–≤
2. üéµ **Zaycev.net** - —Ä—É—Å—Å–∫–æ—è–∑—ã—á–Ω–∞—è –∏ –º–∏—Ä–æ–≤–∞—è –º—É–∑—ã–∫–∞
3. üîç **–ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–µ –∏—Å—Ç–æ—á–Ω–∏–∫–∏** - –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –ø–ª–æ—â–∞–¥–∫–∏

**–ü—Ä–∏–º–µ—Ä—ã –∑–∞–ø—Ä–æ—Å–æ–≤:**
‚Ä¢ "Imagine Dragons Radioactive"
‚Ä¢ "–ú–æ–Ω–µ—Ç–æ—á–∫–∞ - –ö–∞–∂–¥—ã–π —Ä–∞–∑"  
‚Ä¢ "Eminem Lose Yourself"
‚Ä¢ "Miyagi Kosandra"

**–ö–∞–∫ —ç—Ç–æ —Ä–∞–±–æ—Ç–∞–µ—Ç:**
1. –ò—â–µ–º —Ç—Ä–µ–∫ –Ω–∞ –ø–µ—Ä–≤–æ–º –∏—Å—Ç–æ—á–Ω–∏–∫–µ
2. –ï—Å–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω - –ø–µ—Ä–µ—Ö–æ–¥–∏–º –∫ —Å–ª–µ–¥—É—é—â–µ–º—É
3. –ö–∞–∫ —Ç–æ–ª—å–∫–æ –Ω–∞–π–¥–µ–Ω - —Å–∫–∞—á–∏–≤–∞–µ–º –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º

**–ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞:**
‚Ä¢ –í—ã—Å–æ–∫–∏–π –ø—Ä–æ—Ü–µ–Ω—Ç —É—Å–ø–µ—à–Ω—ã—Ö –ø–æ–∏—Å–∫–æ–≤
‚Ä¢ –†–∞–∑–Ω–æ–æ–±—Ä–∞–∑–∏–µ –º—É–∑—ã–∫–∞–ª—å–Ω—ã—Ö —Å—Ç–∏–ª–µ–π
‚Ä¢ –û–±—Ö–æ–¥ –±–ª–æ–∫–∏—Ä–æ–≤–æ–∫ –æ—Ç–¥–µ–ª—å–Ω—ã—Ö –ø–ª–æ—â–∞–¥–æ–∫
‚Ä¢ –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –≤—ã–±–æ—Ä –ª—É—á—à–µ–≥–æ –∫–∞—á–µ—Å—Ç–≤–∞

**–¢–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏:**
‚Ä¢ –ö–∞—á–µ—Å—Ç–≤–æ: MP3 –¥–æ 320kbps
‚Ä¢ –ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä: 50MB
‚Ä¢ –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å: 10 –º–∏–Ω—É—Ç

**–û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è:**
‚Ä¢ –ù–µ–∫–æ—Ç–æ—Ä—ã–µ —Ç—Ä–µ–∫–∏ –º–æ–≥—É—Ç –±—ã—Ç—å –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã
‚Ä¢ –í—Ä–µ–º—è –ø–æ–∏—Å–∫–∞: 30-60 —Å–µ–∫—É–Ω–¥
‚Ä¢ –ê–≤—Ç–æ—Ä—Å–∫–∏–µ –ø—Ä–∞–≤–∞ —Å–æ–±–ª—é–¥–∞—é—Ç—Å—è

**–ö–æ–º–∞–Ω–¥—ã:**
/start - –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é
/help - —ç—Ç–∞ —Å–ø—Ä–∞–≤–∫–∞""",

    "search_prompt": """üîç **–ú—É–ª—å—Ç–∏–∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤—ã–π –ø–æ–∏—Å–∫ –º—É–∑—ã–∫–∏**

–û—Ç–ø—Ä–∞–≤—å—Ç–µ –º–Ω–µ –Ω–∞–∑–≤–∞–Ω–∏–µ —Ç—Ä–µ–∫–∞, –∫–æ—Ç–æ—Ä—ã–π —Ö–æ—Ç–∏—Ç–µ –Ω–∞–π—Ç–∏.

**–ü—Ä–∏–º–µ—Ä—ã –∑–∞–ø—Ä–æ—Å–æ–≤:**
‚Ä¢ Imagine Dragons Radioactive  
‚Ä¢ The Beatles - Hey Jude
‚Ä¢ –ú–æ–Ω–µ—Ç–æ—á–∫–∞ –ö–∞–∂–¥—ã–π —Ä–∞–∑
‚Ä¢ Drake God's Plan
‚Ä¢ Billie Eilish bad guy

**–ò—Å—Ç–æ—á–Ω–∏–∫–∏ –ø–æ–∏—Å–∫–∞:**
üé• YouTube ‚Üí üéµ Zaycev.net ‚Üí üîç –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–µ

–Ø –Ω–∞–π–¥—É —Ç—Ä–µ–∫ –Ω–∞ –æ–¥–Ω–æ–π –∏–∑ –ø–ª–æ—â–∞–¥–æ–∫ –∏ –æ—Ç–ø—Ä–∞–≤–ª—é –∞—É–¥–∏–æ—Ñ–∞–π–ª.""",

    "searching_youtube": "üé• –ò—â—É –Ω–∞ **YouTube**: {}",
    "searching_zaycev": "üéµ –ò—â—É –Ω–∞ **Zaycev.net**: {}",
    "searching_alternative": "üîç –ò—â—É –≤ **–∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã—Ö –∏—Å—Ç–æ—á–Ω–∏–∫–∞—Ö**: {}",
    "downloading": "üì• –°–∫–∞—á–∏–≤–∞—é —Å **{}**: {}",
    "sending": "üì§ –û—Ç–ø—Ä–∞–≤–ª—è—é: {}",
    "found_on": "‚úÖ –ù–∞–π–¥–µ–Ω–æ –Ω–∞: **{}**",
    "not_found_anywhere": "‚ùå –ù–µ –Ω–∞–π–¥–µ–Ω: **{}**\n\nüîç –ü–æ–∏—Å–∫ –≤—ã–ø–æ–ª–Ω–µ–Ω –Ω–∞ –≤—Å–µ—Ö –ø–ª–æ—â–∞–¥–∫–∞—Ö:\n‚Ä¢ YouTube\n‚Ä¢ Zaycev.net\n‚Ä¢ –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–µ –∏—Å—Ç–æ—á–Ω–∏–∫–∏\n\n–ü–æ–ø—Ä–æ–±—É–π—Ç–µ:\n‚Ä¢ –ò–∑–º–µ–Ω–∏—Ç—å –∑–∞–ø—Ä–æ—Å\n‚Ä¢ –î–æ–±–∞–≤–∏—Ç—å –∏–º—è –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—è\n‚Ä¢ –ù–∞–ø–∏—Å–∞—Ç—å –Ω–∞ –∞–Ω–≥–ª–∏–π—Å–∫–æ–º/—Ä—É—Å—Å–∫–æ–º",
    "too_short": "‚ùå –°–ª–∏—à–∫–æ–º –∫–æ—Ä–æ—Ç–∫–∏–π –∑–∞–ø—Ä–æ—Å. –ù–∞–ø–∏—à–∏—Ç–µ —Ö–æ—Ç—è –±—ã 2 —Å–∏–º–≤–æ–ª–∞.",
    "too_long": "‚ùå –°–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π –∑–∞–ø—Ä–æ—Å. –ú–∞–∫—Å–∏–º—É–º 100 —Å–∏–º–≤–æ–ª–æ–≤.",
    "too_long_track": "‚ùå –¢—Ä–µ–∫ —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π (–±–æ–ª—å—à–µ 10 –º–∏–Ω—É—Ç)",
    "too_big_file": "‚ùå –§–∞–π–ª —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π (–±–æ–ª—å—à–µ 50MB)",
    "error": "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–∏—Å–∫–µ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑ —á–µ—Ä–µ–∑ –º–∏–Ω—É—Ç—É.",
}

class MusicStates(StatesGroup):
    waiting_search_query = State()

class MultiSourceDownloader:
    def __init__(self):
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
            'Accept-Language': 'ru-RU,ru;q=0.8,en-US;q=0.5,en;q=0.3',
            'Accept-Encoding': 'gzip, deflate',
            'Connection': 'keep-alive',
            'Upgrade-Insecure-Requests': '1'
        })

    async def search_youtube(self, query: str) -> Optional[str]:
        """–ü–æ–∏—Å–∫ –Ω–∞ YouTube —á–µ—Ä–µ–∑ yt-dlp"""
        try:
            logger.info(f"YouTube search: {query}")
            output_path = os.path.join(TEMP_DIR, f"yt_{int(time.time())}")

            ydl_opts = {
                'format': 'bestaudio[ext=m4a]/bestaudio/best',
                'outtmpl': f'{output_path}.%(ext)s',
                'quiet': True,
                'no_warnings': True,
                'extractaudio': True,
                'audioformat': 'mp3',
                'audioquality': '192',
                'prefer_ffmpeg': True,
                'keepvideo': False,
                'socket_timeout': 30,
                'postprocessors': [{
                    'key': 'FFmpegExtractAudio',
                    'preferredcodec': 'mp3',
                    'preferredquality': '192',
                }],
            }

            search_query = f"ytsearch1:{query}"

            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                info = ydl.extract_info(search_query, download=False)

                if not info or not info.get('entries'):
                    logger.warning(f"YouTube: No results for {query}")
                    return None

                video_info = info['entries'][0]
                duration = video_info.get('duration', 0)
                title = video_info.get('title', 'Unknown')

                logger.info(f"YouTube found: {title} ({duration}s)")

                if duration and duration > MAX_DURATION:
                    logger.warning(f"YouTube: Track too long {duration}s")
                    return "TOO_LONG"

                ydl.download([video_info['webpage_url']])

                mp3_file = f"{output_path}.mp3"
                if os.path.exists(mp3_file):
                    file_size = os.path.getsize(mp3_file)
                    logger.info(f"YouTube: Downloaded {file_size} bytes")

                    if file_size <= MAX_FILE_SIZE:
                        return mp3_file
                    else:
                        os.remove(mp3_file)
                        logger.warning(f"YouTube: File too large {file_size}")
                        return "TOO_BIG"

                logger.warning("YouTube: MP3 file not found after processing")
                return None

        except Exception as e:
            logger.error(f"YouTube search error: {e}")
            return None

    async def search_zaycev(self, query: str) -> Optional[str]:
        """–£–ª—É—á—à–µ–Ω–Ω—ã–π –ø–æ–∏—Å–∫ –Ω–∞ Zaycev.net"""
        try:
            logger.info(f"Zaycev search: {query}")

            # –ü–æ–∏—Å–∫ —Ç—Ä–µ–∫–∞ —Å —É–ª—É—á—à–µ–Ω–Ω—ã–º –ø–∞—Ä—Å–∏–Ω–≥–æ–º
            search_url = f"https://zaycev.net/search.html?query_search={urllib.parse.quote(query)}"
            logger.debug(f"Zaycev search URL: {search_url}")

            response = self.session.get(search_url, timeout=20)
            response.raise_for_status()

            soup = BeautifulSoup(response.text, 'html.parser')

            # –ò—â–µ–º —Ç—Ä–µ–∫–∏ –≤ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞—Ö –ø–æ–∏—Å–∫–∞ (–æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–µ —Å–µ–ª–µ–∫—Ç–æ—Ä—ã)
            track_elements = soup.select('div.musicset__item')
            if not track_elements:
                # –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–µ —Å–µ–ª–µ–∫—Ç–æ—Ä—ã
                track_elements = soup.select('div.music-item')
            if not track_elements:
                track_elements = soup.select('div[class*="track"]')

            if not track_elements:
                logger.warning(f"Zaycev: No track elements found for {query}")
                return None

            # –ë–µ—Ä–µ–º –ø–µ—Ä–≤—ã–π –Ω–∞–π–¥–µ–Ω–Ω—ã–π —Ç—Ä–µ–∫
            track_element = track_elements[0]

            # –ò—â–µ–º —Å—Å—ã–ª–∫—É –Ω–∞ —Ç—Ä–µ–∫
            track_link = track_element.select_one('a[href*="/music/"]')
            if not track_link:
                track_link = track_element.select_one('a[href*="/pages/"]')

            if not track_link:
                logger.warning("Zaycev: No track link found")
                return None

            track_url = track_link.get('href')
            if track_url.startswith('/'):
                track_url = "https://zaycev.net" + track_url

            logger.debug(f"Zaycev track URL: {track_url}")

            # –ü–µ—Ä–µ—Ö–æ–¥–∏–º –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü—É —Ç—Ä–µ–∫–∞
            track_response = self.session.get(track_url, timeout=20)
            track_response.raise_for_status()

            track_soup = BeautifulSoup(track_response.text, 'html.parser')

            # –ò—â–µ–º —Å—Å—ã–ª–∫—É –Ω–∞ —Å–∫–∞—á–∏–≤–∞–Ω–∏–µ MP3 (–º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã)
            download_link = None

            # –í–∞—Ä–∏–∞–Ω—Ç 1: –ø—Ä—è–º–∞—è —Å—Å—ã–ª–∫–∞ –≤ audio —Ç–µ–≥–µ
            audio_element = track_soup.select_one('audio source[src*=".mp3"]')
            if audio_element:
                download_link = audio_element.get('src')
                logger.debug(f"Zaycev: Found audio source {download_link}")

            # –í–∞—Ä–∏–∞–Ω—Ç 2: data-url –∞—Ç—Ä–∏–±—É—Ç
            if not download_link:
                data_element = track_soup.select_one('[data-url*=".mp3"]')
                if data_element:
                    download_link = data_element.get('data-url')
                    logger.debug(f"Zaycev: Found data-url {download_link}")

            # –í–∞—Ä–∏–∞–Ω—Ç 3: –∫–Ω–æ–ø–∫–∞ —Å–∫–∞—á–∏–≤–∞–Ω–∏—è
            if not download_link:
                download_btn = track_soup.select_one('a[href*=".mp3"]')
                if download_btn:
                    download_link = download_btn.get('href')
                    logger.debug(f"Zaycev: Found download button {download_link}")

            # –í–∞—Ä–∏–∞–Ω—Ç 4: JavaScript –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
            if not download_link:
                script_tags = track_soup.find_all('script')
                for script in script_tags:
                    if script.string and '.mp3' in script.string:
                        # –ò—â–µ–º —Å—Å—ã–ª–∫–∏ –Ω–∞ MP3 –≤ JavaScript
                        mp3_matches = re.findall(r'["']([^"']*\.mp3[^"']*)["']', script.string)
                        if mp3_matches:
                            download_link = mp3_matches[0]
                            logger.debug(f"Zaycev: Found in JS {download_link}")
                            break

            if not download_link:
                logger.warning("Zaycev: No download link found")
                return None

            # –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º —Å—Å—ã–ª–∫—É
            if download_link.startswith('//'):
                download_link = 'https:' + download_link
            elif download_link.startswith('/'):
                download_link = 'https://zaycev.net' + download_link
            elif not download_link.startswith('http'):
                download_link = 'https://zaycev.net/' + download_link

            logger.info(f"Zaycev: Downloading from {download_link}")

            # –°–∫–∞—á–∏–≤–∞–µ–º —Ñ–∞–π–ª
            output_path = os.path.join(TEMP_DIR, f"zaycev_{int(time.time())}.mp3")

            audio_response = self.session.get(download_link, timeout=30, stream=True)
            audio_response.raise_for_status()

            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø–æ–ª—É—á–∏–ª–∏ –∞—É–¥–∏–æ—Ñ–∞–π–ª
            content_type = audio_response.headers.get('content-type', '').lower()
            if 'audio' not in content_type and 'application/octet-stream' not in content_type:
                logger.warning(f"Zaycev: Invalid content type {content_type}")
                return None

            with open(output_path, 'wb') as f:
                for chunk in audio_response.iter_content(chunk_size=8192):
                    if chunk:
                        f.write(chunk)

            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–∞–∑–º–µ—Ä —Ñ–∞–π–ª–∞
            file_size = os.path.getsize(output_path)
            logger.info(f"Zaycev: Downloaded {file_size} bytes")

            if file_size < 1000:  # –°–ª–∏—à–∫–æ–º –º–∞–ª–µ–Ω—å–∫–∏–π —Ñ–∞–π–ª
                os.remove(output_path)
                logger.warning("Zaycev: File too small, probably error page")
                return None

            if file_size > MAX_FILE_SIZE:
                os.remove(output_path)
                logger.warning(f"Zaycev: File too large {file_size}")
                return "TOO_BIG"

            return output_path

        except Exception as e:
            logger.error(f"Zaycev search error: {e}")
            return None

    async def search_alternative(self, query: str) -> Optional[str]:
        """–ü–æ–∏—Å–∫ –≤ –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã—Ö –∏—Å—Ç–æ—á–Ω–∏–∫–∞—Ö"""
        try:
            logger.info(f"Alternative search: {query}")

            # –ü–æ–ø—Ä–æ–±—É–µ–º –¥—Ä—É–≥–∏–µ –∏—Å—Ç–æ—á–Ω–∏–∫–∏ —á–µ—Ä–µ–∑ yt-dlp
            sources = [
                f"ytsearch1:{query} site:soundcloud.com",
                f"ytsearch1:{query} audio",
                f"ytsearch1:{query} music"
            ]

            for search_query in sources:
                try:
                    output_path = os.path.join(TEMP_DIR, f"alt_{int(time.time())}")

                    ydl_opts = {
                        'format': 'bestaudio/best',
                        'outtmpl': f'{output_path}.%(ext)s',
                        'quiet': True,
                        'no_warnings': True,
                        'extractaudio': True,
                        'audioformat': 'mp3',
                        'audioquality': '192',
                        'prefer_ffmpeg': True,
                        'socket_timeout': 20,
                    }

                    with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                        info = ydl.extract_info(search_query, download=False)

                        if not info or not info.get('entries'):
                            continue

                        track_info = info['entries'][0]
                        duration = track_info.get('duration', 0)

                        if duration and duration > MAX_DURATION:
                            continue

                        ydl.download([track_info['webpage_url']])

                        mp3_file = f"{output_path}.mp3"
                        if os.path.exists(mp3_file):
                            file_size = os.path.getsize(mp3_file)
                            if file_size <= MAX_FILE_SIZE:
                                logger.info(f"Alternative: Found via {search_query}")
                                return mp3_file
                            else:
                                os.remove(mp3_file)

                except Exception as e:
                    logger.debug(f"Alternative source failed: {e}")
                    continue

            return None

        except Exception as e:
            logger.error(f"Alternative search error: {e}")
            return None

    async def download_track(self, query: str, status_callback=None) -> tuple[Optional[str], str]:
        """–û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –ø–æ–∏—Å–∫–∞ –ø–æ –≤—Å–µ–º –∏—Å—Ç–æ—á–Ω–∏–∫–∞–º"""
        sources = [
            ("YouTube", "searching_youtube", self.search_youtube),
            ("Zaycev.net", "searching_zaycev", self.search_zaycev),
            ("Alternative", "searching_alternative", self.search_alternative)
        ]

        for source_name, status_key, search_func in sources:
            try:
                if status_callback:
                    await status_callback(status_key, query)

                result = await search_func(query)

                if result == "TOO_LONG":
                    return "TOO_LONG", source_name
                elif result == "TOO_BIG":
                    return "TOO_BIG", source_name
                elif result and os.path.exists(result):
                    logger.info(f"SUCCESS: Found on {source_name}")
                    return result, source_name

                # –ü–∞—É–∑–∞ –º–µ–∂–¥—É –∏—Å—Ç–æ—á–Ω–∏–∫–∞–º–∏
                await asyncio.sleep(2)

            except Exception as e:
                logger.error(f"Error searching {source_name}: {e}")
                continue

        return None, "nowhere"

    def cleanup_file(self, file_path: str):
        """–£–¥–∞–ª–µ–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–Ω–æ–≥–æ —Ñ–∞–π–ª–∞"""
        try:
            if file_path and os.path.exists(file_path):
                os.remove(file_path)
                logger.debug(f"Cleaned up: {file_path}")
        except Exception as e:
            logger.error(f"Error deleting file {file_path}: {e}")

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
downloader = MultiSourceDownloader()

# –°–æ–∑–¥–∞–Ω–∏–µ –∫–ª–∞–≤–∏–∞—Ç—É—Ä
def main_menu():
    """–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é –±–æ—Ç–∞"""
    keyboard = [
        [InlineKeyboardButton(text="üîç –ü–æ–∏—Å–∫ –º—É–∑—ã–∫–∏", callback_data="search_music")],
        [InlineKeyboardButton(text="‚ÑπÔ∏è –ü–æ–º–æ—â—å", callback_data="help")]
    ]
    return InlineKeyboardMarkup(inline_keyboard=keyboard)

def back_menu():
    """–ö–Ω–æ–ø–∫–∞ –≤–æ–∑–≤—Ä–∞—Ç–∞ –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é"""
    keyboard = [
        [InlineKeyboardButton(text="üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="main_menu")]
    ]
    return InlineKeyboardMarkup(inline_keyboard=keyboard)

# –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∫–æ–º–∞–Ω–¥
@dp.message(Command("start"))
async def start_cmd(msg: Message):
    """–ö–æ–º–∞–Ω–¥–∞ /start"""
    await msg.answer(TEXTS["welcome"], reply_markup=main_menu(), parse_mode="Markdown")

@dp.message(Command("help"))  
async def help_cmd(msg: Message):
    """–ö–æ–º–∞–Ω–¥–∞ /help"""
    await msg.answer(TEXTS["help"], reply_markup=back_menu(), parse_mode="Markdown")

# –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ callback-–∑–∞–ø—Ä–æ—Å–æ–≤
@dp.callback_query(F.data == "main_menu")
async def main_menu_handler(query: CallbackQuery):
    """–í–æ–∑–≤—Ä–∞—Ç –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é"""
    await query.message.edit_text(TEXTS["welcome"], reply_markup=main_menu(), parse_mode="Markdown")

@dp.callback_query(F.data == "help")
async def help_handler(query: CallbackQuery):
    """–°–ø—Ä–∞–≤–∫–∞"""
    await query.message.edit_text(TEXTS["help"], reply_markup=back_menu(), parse_mode="Markdown")

@dp.callback_query(F.data == "search_music")
async def search_music_handler(query: CallbackQuery, state: FSMContext):
    """–ù–∞—á–∞–ª–æ –ø–æ–∏—Å–∫–∞ –º—É–∑—ã–∫–∏"""
    await query.message.edit_text(TEXTS["search_prompt"], parse_mode="Markdown")
    await state.set_state(MusicStates.waiting_search_query)

# –û—Å–Ω–æ–≤–Ω–∞—è –ª–æ–≥–∏–∫–∞ –ø–æ–∏—Å–∫–∞ –∏ —Å–∫–∞—á–∏–≤–∞–Ω–∏—è
async def process_music_search(message: Message, query: str, is_state: bool = False):
    """–û–±—â–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –ø–æ–∏—Å–∫–∞ –º—É–∑—ã–∫–∏"""
    # –í–∞–ª–∏–¥–∞—Ü–∏—è –∑–∞–ø—Ä–æ—Å–∞
    if len(query) < 2:
        await message.answer(TEXTS["too_short"])
        return

    if len(query) > 100:
        await message.answer(TEXTS["too_long"])
        return

    # –ò—Å–∫–ª—é—á–∞–µ–º –æ–±—ã—á–Ω—ã–µ —Ñ—Ä–∞–∑—ã
    excluded = ['–ø—Ä–∏–≤–µ—Ç', 'hello', '–∫–∞–∫ –¥–µ–ª–∞', '—Å–ø–∞—Å–∏–±–æ', '–ø–æ–∫–∞', 'hi', 'hey', '–¥–æ–±—Ä—ã–π –¥–µ–Ω—å', '–¥–æ–±—Ä—ã–π –≤–µ—á–µ—Ä']
    if any(word in query.lower() for word in excluded):
        greeting = "üëã –ü—Ä–∏–≤–µ—Ç! –ù–∞–ø–∏—à–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ —Ç—Ä–µ–∫–∞ –¥–ª—è –ø–æ–∏—Å–∫–∞ –º—É–∑—ã–∫–∏."
        if is_state:
            await message.answer(greeting)
        else:
            await message.answer(greeting, reply_markup=main_menu())
        return

    # –°–æ–∑–¥–∞–µ–º —Å—Ç–∞—Ç—É—Å–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
    status_msg = await message.answer("üîç **–ù–∞—á–∏–Ω–∞—é –ø–æ–∏—Å–∫...**", parse_mode="Markdown")

    # –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å—Ç–∞—Ç—É—Å–∞
    async def update_status(status_key: str, track_name: str):
        try:
            if status_key == "searching_youtube":
                text = TEXTS["searching_youtube"].format(track_name)
            elif status_key == "searching_zaycev":
                text = TEXTS["searching_zaycev"].format(track_name)
            elif status_key == "searching_alternative":
                text = TEXTS["searching_alternative"].format(track_name)
            else:
                text = f"üîç –ò—â—É: **{track_name}**"

            await status_msg.edit_text(text, parse_mode="Markdown")
        except Exception as e:
            logger.debug(f"Status update error: {e}")

    try:
        # –ü–æ–∏—Å–∫ –ø–æ –≤—Å–µ–º –∏—Å—Ç–æ—á–Ω–∏–∫–∞–º
        result, source = await downloader.download_track(query, update_status)

        if result == "TOO_LONG":
            await status_msg.edit_text(TEXTS["too_long_track"], parse_mode="Markdown")
        elif result == "TOO_BIG":
            await status_msg.edit_text(TEXTS["too_big_file"], parse_mode="Markdown")
        elif result and os.path.exists(result):
            await status_msg.edit_text(TEXTS["sending"].format(query), parse_mode="Markdown")

            # –û—Ç–ø—Ä–∞–≤–∫–∞ –∞—É–¥–∏–æ—Ñ–∞–π–ª–∞
            try:
                with open(result, "rb") as audio_file:
                    caption = f"üéµ {query}\n‚úÖ –ù–∞–π–¥–µ–Ω–æ –Ω–∞: **{source}**"
                    await message.answer_audio(
                        audio=audio_file,
                        caption=caption,
                        parse_mode="Markdown"
                    )

                downloader.cleanup_file(result)

                # –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ç—É—Å–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
                try:
                    await status_msg.delete()
                except:
                    pass

                # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –º–µ–Ω—é, –µ—Å–ª–∏ —ç—Ç–æ –Ω–µ –∏–∑ —Å–æ—Å—Ç–æ—è–Ω–∏—è
                if not is_state:
                    await message.answer("‚úÖ **–ì–æ—Ç–æ–≤–æ!** –•–æ—Ç–∏—Ç–µ –Ω–∞–π—Ç–∏ –µ—â–µ –º—É–∑—ã–∫—É?", 
                                       reply_markup=main_menu(), parse_mode="Markdown")

            except Exception as e:
                logger.error(f"Error sending audio: {e}")
                await status_msg.edit_text("‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Ñ–∞–π–ª–∞", parse_mode="Markdown")
        else:
            await status_msg.edit_text(TEXTS["not_found_anywhere"].format(query), parse_mode="Markdown")

    except Exception as e:
        logger.error(f"Error processing search query '{query}': {e}")
        await status_msg.edit_text(TEXTS["error"], parse_mode="Markdown")

# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –ø–æ–∏—Å–∫–æ–≤–æ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è
@dp.message(MusicStates.waiting_search_query)
async def process_search_query(msg: Message, state: FSMContext):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–æ–∏—Å–∫–æ–≤–æ–≥–æ –∑–∞–ø—Ä–æ—Å–∞ –≤ —Å–æ—Å—Ç–æ—è–Ω–∏–∏"""
    query = msg.text.strip()
    await process_music_search(msg, query, is_state=True)

    # –û—á–∏—â–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∏ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –º–µ–Ω—é
    await state.clear()
    await asyncio.sleep(2)
    await msg.answer(TEXTS["welcome"], reply_markup=main_menu(), parse_mode="Markdown")

# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –æ–±—ã—á–Ω—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π (–ø—Ä—è–º–æ–π –ø–æ–∏—Å–∫)
@dp.message(F.text & ~F.text.startswith('/'))
async def direct_search_handler(message: Message):
    """–ü—Ä—è–º–æ–π –ø–æ–∏—Å–∫ –±–µ–∑ –∫–æ–º–∞–Ω–¥"""
    query = message.text.strip()
    await process_music_search(message, query, is_state=False)

async def main():
    """–ó–∞–ø—É—Å–∫ –±–æ—Ç–∞"""
    try:
        logger.info("üéµ Starting Fixed Multi-Source Music Bot...")

        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã—Ö –Ω–∞—Å—Ç—Ä–æ–µ–∫
        if not BOT_TOKEN:
            logger.error("‚ùå BOT_TOKEN not found in environment variables!")
            return

        # –°–æ–∑–¥–∞–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–Ω–æ–π –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏
        Path(TEMP_DIR).mkdir(exist_ok=True)

        # –ü—Ä–æ–≤–µ—Ä–∫–∞ FFmpeg
        import shutil
        if not shutil.which('ffmpeg'):
            logger.warning("‚ö†Ô∏è FFmpeg not found! Audio conversion may not work properly.")
        else:
            logger.info("‚úÖ FFmpeg found")

        logger.info("üöÄ Bot started successfully!")
        logger.info("üåê Available sources: YouTube, Zaycev.net, Alternative sources")

        await dp.start_polling(bot, skip_updates=True)

    except Exception as e:
        logger.error(f"‚ùå Bot startup error: {e}")
        import traceback
        logger.error(traceback.format_exc())
    finally:
        await bot.session.close()

if __name__ == "__main__":
    asyncio.run(main())
